// <auto-generated>
/*
 * Moira Alert
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: master
 * Contact: kontur.moira.alert@gmail.com
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;
using System.Text.Json;
using System.Text.Json.Serialization;
using System.ComponentModel.DataAnnotations;
using Moira.ApiClient.Client;

namespace Moira.ApiClient.Model
{
    /// <summary>
    /// DtoTrigger
    /// </summary>
    public partial class DtoTrigger : IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="DtoTrigger" /> class.
        /// </summary>
        /// <param name="aloneMetrics">A list of targets that have only alone metrics</param>
        /// <param name="clusterId">Shows the exact cluster from where the metrics are fetched</param>
        /// <param name="createdBy">Username who created trigger</param>
        /// <param name="expression">Used if you need more complex logic than provided by WARN/ERROR values</param>
        /// <param name="id">Trigger unique ID</param>
        /// <param name="isRemote">Shows if trigger is remote (graphite-backend) based or stored inside Moira-Redis DB  Deprecated: Use TriggerSource field instead</param>
        /// <param name="muteNewMetrics">If true, first event NODATA → OK will be omitted</param>
        /// <param name="name">Trigger name</param>
        /// <param name="patterns">Graphite patterns for trigger</param>
        /// <param name="tags">Set of tags to manipulate subscriptions</param>
        /// <param name="targets">Graphite-like targets: t1, t2, ...</param>
        /// <param name="throttling">throttling</param>
        /// <param name="triggerSource">Shows the type of source from where the metrics are fetched</param>
        /// <param name="triggerType">Could be: rising, falling, expression</param>
        /// <param name="updatedBy">Username who updated trigger</param>
        /// <param name="createdAt">Datetime when the trigger was created</param>
        /// <param name="desc">Description string</param>
        /// <param name="errorValue">ERROR threshold</param>
        /// <param name="sched">sched</param>
        /// <param name="ttl">When there are no metrics for trigger, Moira will switch metric to TTLState state after TTL seconds</param>
        /// <param name="ttlState">When there are no metrics for trigger, Moira will switch metric to TTLState state after TTL seconds</param>
        /// <param name="updatedAt">Datetime  when the trigger was updated</param>
        /// <param name="warnValue">WARN threshold</param>
        [JsonConstructor]
        public DtoTrigger(Dictionary<string, bool> aloneMetrics, string clusterId, string createdBy, string expression, string id, bool isRemote, bool muteNewMetrics, string name, List<string> patterns, List<string> tags, List<string> targets, long throttling, string triggerSource, string triggerType, string updatedBy, string createdAt = default, Option<string> desc = default, decimal? errorValue = default, Option<MoiraScheduleData> sched = default, Option<long?> ttl = default, Option<string> ttlState = default, string updatedAt = default, decimal? warnValue = default)
        {
            AloneMetrics = aloneMetrics;
            ClusterId = clusterId;
            CreatedBy = createdBy;
            Expression = expression;
            Id = id;
            IsRemote = isRemote;
            MuteNewMetrics = muteNewMetrics;
            Name = name;
            Patterns = patterns;
            Tags = tags;
            Targets = targets;
            Throttling = throttling;
            TriggerSource = triggerSource;
            TriggerType = triggerType;
            UpdatedBy = updatedBy;
            CreatedAt = createdAt;
            DescOption = desc;
            ErrorValue = errorValue;
            SchedOption = sched;
            TtlOption = ttl;
            TtlStateOption = ttlState;
            UpdatedAt = updatedAt;
            WarnValue = warnValue;
            OnCreated();
        }

        partial void OnCreated();

        /// <summary>
        /// A list of targets that have only alone metrics
        /// </summary>
        /// <value>A list of targets that have only alone metrics</value>
        /* <example>{t1&#x3D;true}</example> */
        [JsonPropertyName("alone_metrics")]
        public Dictionary<string, bool> AloneMetrics { get; set; }

        /// <summary>
        /// Shows the exact cluster from where the metrics are fetched
        /// </summary>
        /// <value>Shows the exact cluster from where the metrics are fetched</value>
        /* <example>default</example> */
        [JsonPropertyName("cluster_id")]
        public string ClusterId { get; set; }

        /// <summary>
        /// Username who created trigger
        /// </summary>
        /// <value>Username who created trigger</value>
        [JsonPropertyName("created_by")]
        public string CreatedBy { get; set; }

        /// <summary>
        /// Used if you need more complex logic than provided by WARN/ERROR values
        /// </summary>
        /// <value>Used if you need more complex logic than provided by WARN/ERROR values</value>
        [JsonPropertyName("expression")]
        public string Expression { get; set; }

        /// <summary>
        /// Trigger unique ID
        /// </summary>
        /// <value>Trigger unique ID</value>
        /* <example>292516ed-4924-4154-a62c-ebe312431fce</example> */
        [JsonPropertyName("id")]
        public string Id { get; set; }

        /// <summary>
        /// Shows if trigger is remote (graphite-backend) based or stored inside Moira-Redis DB  Deprecated: Use TriggerSource field instead
        /// </summary>
        /// <value>Shows if trigger is remote (graphite-backend) based or stored inside Moira-Redis DB  Deprecated: Use TriggerSource field instead</value>
        /* <example>false</example> */
        [JsonPropertyName("is_remote")]
        public bool IsRemote { get; set; }

        /// <summary>
        /// If true, first event NODATA → OK will be omitted
        /// </summary>
        /// <value>If true, first event NODATA → OK will be omitted</value>
        /* <example>false</example> */
        [JsonPropertyName("mute_new_metrics")]
        public bool MuteNewMetrics { get; set; }

        /// <summary>
        /// Trigger name
        /// </summary>
        /// <value>Trigger name</value>
        /* <example>Not enough disk space left</example> */
        [JsonPropertyName("name")]
        public string Name { get; set; }

        /// <summary>
        /// Graphite patterns for trigger
        /// </summary>
        /// <value>Graphite patterns for trigger</value>
        /* <example>[]</example> */
        [JsonPropertyName("patterns")]
        public List<string> Patterns { get; set; }

        /// <summary>
        /// Set of tags to manipulate subscriptions
        /// </summary>
        /// <value>Set of tags to manipulate subscriptions</value>
        /* <example>[server, disk]</example> */
        [JsonPropertyName("tags")]
        public List<string> Tags { get; set; }

        /// <summary>
        /// Graphite-like targets: t1, t2, ...
        /// </summary>
        /// <value>Graphite-like targets: t1, t2, ...</value>
        /* <example>[devOps.my_server.hdd.freespace_mbytes]</example> */
        [JsonPropertyName("targets")]
        public List<string> Targets { get; set; }

        /// <summary>
        /// Gets or Sets Throttling
        /// </summary>
        /* <example>0</example> */
        [JsonPropertyName("throttling")]
        public long Throttling { get; set; }

        /// <summary>
        /// Shows the type of source from where the metrics are fetched
        /// </summary>
        /// <value>Shows the type of source from where the metrics are fetched</value>
        /* <example>graphite_local</example> */
        [JsonPropertyName("trigger_source")]
        public string TriggerSource { get; set; }

        /// <summary>
        /// Could be: rising, falling, expression
        /// </summary>
        /// <value>Could be: rising, falling, expression</value>
        /* <example>rising</example> */
        [JsonPropertyName("trigger_type")]
        public string TriggerType { get; set; }

        /// <summary>
        /// Username who updated trigger
        /// </summary>
        /// <value>Username who updated trigger</value>
        [JsonPropertyName("updated_by")]
        public string UpdatedBy { get; set; }

        /// <summary>
        /// Datetime when the trigger was created
        /// </summary>
        /// <value>Datetime when the trigger was created</value>
        [JsonPropertyName("created_at")]
        public string CreatedAt { get; set; }

        /// <summary>
        /// Used to track the state of Desc
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string> DescOption { get; private set; }

        /// <summary>
        /// Description string
        /// </summary>
        /// <value>Description string</value>
        /* <example>check the size of /var/log</example> */
        [JsonPropertyName("desc")]
        public string Desc { get { return this.DescOption; } set { this.DescOption = new Option<string>(value); } }

        /// <summary>
        /// ERROR threshold
        /// </summary>
        /// <value>ERROR threshold</value>
        /* <example>1000</example> */
        [JsonPropertyName("error_value")]
        public decimal? ErrorValue { get; set; }

        /// <summary>
        /// Used to track the state of Sched
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<MoiraScheduleData> SchedOption { get; private set; }

        /// <summary>
        /// Gets or Sets Sched
        /// </summary>
        [JsonPropertyName("sched")]
        public MoiraScheduleData Sched { get { return this.SchedOption; } set { this.SchedOption = new Option<MoiraScheduleData>(value); } }

        /// <summary>
        /// Used to track the state of Ttl
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<long?> TtlOption { get; private set; }

        /// <summary>
        /// When there are no metrics for trigger, Moira will switch metric to TTLState state after TTL seconds
        /// </summary>
        /// <value>When there are no metrics for trigger, Moira will switch metric to TTLState state after TTL seconds</value>
        /* <example>600</example> */
        [JsonPropertyName("ttl")]
        public long? Ttl { get { return this.TtlOption; } set { this.TtlOption = new Option<long?>(value); } }

        /// <summary>
        /// Used to track the state of TtlState
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string> TtlStateOption { get; private set; }

        /// <summary>
        /// When there are no metrics for trigger, Moira will switch metric to TTLState state after TTL seconds
        /// </summary>
        /// <value>When there are no metrics for trigger, Moira will switch metric to TTLState state after TTL seconds</value>
        /* <example>NODATA</example> */
        [JsonPropertyName("ttl_state")]
        public string TtlState { get { return this.TtlStateOption; } set { this.TtlStateOption = new Option<string>(value); } }

        /// <summary>
        /// Datetime  when the trigger was updated
        /// </summary>
        /// <value>Datetime  when the trigger was updated</value>
        [JsonPropertyName("updated_at")]
        public string UpdatedAt { get; set; }

        /// <summary>
        /// WARN threshold
        /// </summary>
        /// <value>WARN threshold</value>
        /* <example>500</example> */
        [JsonPropertyName("warn_value")]
        public decimal? WarnValue { get; set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class DtoTrigger {\n");
            sb.Append("  AloneMetrics: ").Append(AloneMetrics).Append("\n");
            sb.Append("  ClusterId: ").Append(ClusterId).Append("\n");
            sb.Append("  CreatedBy: ").Append(CreatedBy).Append("\n");
            sb.Append("  Expression: ").Append(Expression).Append("\n");
            sb.Append("  Id: ").Append(Id).Append("\n");
            sb.Append("  IsRemote: ").Append(IsRemote).Append("\n");
            sb.Append("  MuteNewMetrics: ").Append(MuteNewMetrics).Append("\n");
            sb.Append("  Name: ").Append(Name).Append("\n");
            sb.Append("  Patterns: ").Append(Patterns).Append("\n");
            sb.Append("  Tags: ").Append(Tags).Append("\n");
            sb.Append("  Targets: ").Append(Targets).Append("\n");
            sb.Append("  Throttling: ").Append(Throttling).Append("\n");
            sb.Append("  TriggerSource: ").Append(TriggerSource).Append("\n");
            sb.Append("  TriggerType: ").Append(TriggerType).Append("\n");
            sb.Append("  UpdatedBy: ").Append(UpdatedBy).Append("\n");
            sb.Append("  CreatedAt: ").Append(CreatedAt).Append("\n");
            sb.Append("  Desc: ").Append(Desc).Append("\n");
            sb.Append("  ErrorValue: ").Append(ErrorValue).Append("\n");
            sb.Append("  Sched: ").Append(Sched).Append("\n");
            sb.Append("  Ttl: ").Append(Ttl).Append("\n");
            sb.Append("  TtlState: ").Append(TtlState).Append("\n");
            sb.Append("  UpdatedAt: ").Append(UpdatedAt).Append("\n");
            sb.Append("  WarnValue: ").Append(WarnValue).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            yield break;
        }
    }

    /// <summary>
    /// A Json converter for type <see cref="DtoTrigger" />
    /// </summary>
    public class DtoTriggerJsonConverter : JsonConverter<DtoTrigger>
    {
        /// <summary>
        /// Deserializes json to <see cref="DtoTrigger" />
        /// </summary>
        /// <param name="utf8JsonReader"></param>
        /// <param name="typeToConvert"></param>
        /// <param name="jsonSerializerOptions"></param>
        /// <returns></returns>
        /// <exception cref="JsonException"></exception>
        public override DtoTrigger Read(ref Utf8JsonReader utf8JsonReader, Type typeToConvert, JsonSerializerOptions jsonSerializerOptions)
        {
            int currentDepth = utf8JsonReader.CurrentDepth;

            if (utf8JsonReader.TokenType != JsonTokenType.StartObject && utf8JsonReader.TokenType != JsonTokenType.StartArray)
                throw new JsonException();

            JsonTokenType startingTokenType = utf8JsonReader.TokenType;

            Option<Dictionary<string, bool>> aloneMetrics = default;
            Option<string> clusterId = default;
            Option<string> createdBy = default;
            Option<string> expression = default;
            Option<string> id = default;
            Option<bool?> isRemote = default;
            Option<bool?> muteNewMetrics = default;
            Option<string> name = default;
            Option<List<string>> patterns = default;
            Option<List<string>> tags = default;
            Option<List<string>> targets = default;
            Option<long?> throttling = default;
            Option<string> triggerSource = default;
            Option<string> triggerType = default;
            Option<string> updatedBy = default;
            Option<string> createdAt = default;
            Option<string> desc = default;
            Option<decimal?> errorValue = default;
            Option<MoiraScheduleData> sched = default;
            Option<long?> ttl = default;
            Option<string> ttlState = default;
            Option<string> updatedAt = default;
            Option<decimal?> warnValue = default;

            while (utf8JsonReader.Read())
            {
                if (startingTokenType == JsonTokenType.StartObject && utf8JsonReader.TokenType == JsonTokenType.EndObject && currentDepth == utf8JsonReader.CurrentDepth)
                    break;

                if (startingTokenType == JsonTokenType.StartArray && utf8JsonReader.TokenType == JsonTokenType.EndArray && currentDepth == utf8JsonReader.CurrentDepth)
                    break;

                if (utf8JsonReader.TokenType == JsonTokenType.PropertyName && currentDepth == utf8JsonReader.CurrentDepth - 1)
                {
                    string localVarJsonPropertyName = utf8JsonReader.GetString();
                    utf8JsonReader.Read();

                    switch (localVarJsonPropertyName)
                    {
                        case "alone_metrics":
                            aloneMetrics = new Option<Dictionary<string, bool>>(JsonSerializer.Deserialize<Dictionary<string, bool>>(ref utf8JsonReader, jsonSerializerOptions));
                            break;
                        case "cluster_id":
                            clusterId = new Option<string>(utf8JsonReader.GetString());
                            break;
                        case "created_by":
                            createdBy = new Option<string>(utf8JsonReader.GetString());
                            break;
                        case "expression":
                            expression = new Option<string>(utf8JsonReader.GetString());
                            break;
                        case "id":
                            id = new Option<string>(utf8JsonReader.GetString());
                            break;
                        case "is_remote":
                            isRemote = new Option<bool?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (bool?)null : utf8JsonReader.GetBoolean());
                            break;
                        case "mute_new_metrics":
                            muteNewMetrics = new Option<bool?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (bool?)null : utf8JsonReader.GetBoolean());
                            break;
                        case "name":
                            name = new Option<string>(utf8JsonReader.GetString());
                            break;
                        case "patterns":
                            patterns = new Option<List<string>>(JsonSerializer.Deserialize<List<string>>(ref utf8JsonReader, jsonSerializerOptions));
                            break;
                        case "tags":
                            tags = new Option<List<string>>(JsonSerializer.Deserialize<List<string>>(ref utf8JsonReader, jsonSerializerOptions));
                            break;
                        case "targets":
                            targets = new Option<List<string>>(JsonSerializer.Deserialize<List<string>>(ref utf8JsonReader, jsonSerializerOptions));
                            break;
                        case "throttling":
                            throttling = new Option<long?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (long?)null : utf8JsonReader.GetInt64());
                            break;
                        case "trigger_source":
                            triggerSource = new Option<string>(utf8JsonReader.GetString());
                            break;
                        case "trigger_type":
                            triggerType = new Option<string>(utf8JsonReader.GetString());
                            break;
                        case "updated_by":
                            updatedBy = new Option<string>(utf8JsonReader.GetString());
                            break;
                        case "created_at":
                            createdAt = new Option<string>(utf8JsonReader.GetString());
                            break;
                        case "desc":
                            desc = new Option<string>(utf8JsonReader.GetString());
                            break;
                        case "error_value":
                            errorValue = new Option<decimal?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (decimal?)null : utf8JsonReader.GetDecimal());
                            break;
                        case "sched":
                            sched = new Option<MoiraScheduleData>(JsonSerializer.Deserialize<MoiraScheduleData>(ref utf8JsonReader, jsonSerializerOptions));
                            break;
                        case "ttl":
                            ttl = new Option<long?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (long?)null : utf8JsonReader.GetInt64());
                            break;
                        case "ttl_state":
                            ttlState = new Option<string>(utf8JsonReader.GetString());
                            break;
                        case "updated_at":
                            updatedAt = new Option<string>(utf8JsonReader.GetString());
                            break;
                        case "warn_value":
                            warnValue = new Option<decimal?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (decimal?)null : utf8JsonReader.GetDecimal());
                            break;
                        default:
                            break;
                    }
                }
            }

            if (!aloneMetrics.IsSet)
                throw new ArgumentException("Property is required for class DtoTrigger.", nameof(aloneMetrics));

            if (!clusterId.IsSet)
                throw new ArgumentException("Property is required for class DtoTrigger.", nameof(clusterId));

            if (!createdBy.IsSet)
                throw new ArgumentException("Property is required for class DtoTrigger.", nameof(createdBy));

            if (!expression.IsSet)
                throw new ArgumentException("Property is required for class DtoTrigger.", nameof(expression));

            if (!id.IsSet)
                throw new ArgumentException("Property is required for class DtoTrigger.", nameof(id));

            if (!isRemote.IsSet)
                throw new ArgumentException("Property is required for class DtoTrigger.", nameof(isRemote));

            if (!muteNewMetrics.IsSet)
                throw new ArgumentException("Property is required for class DtoTrigger.", nameof(muteNewMetrics));

            if (!name.IsSet)
                throw new ArgumentException("Property is required for class DtoTrigger.", nameof(name));

            if (!patterns.IsSet)
                throw new ArgumentException("Property is required for class DtoTrigger.", nameof(patterns));

            if (!tags.IsSet)
                throw new ArgumentException("Property is required for class DtoTrigger.", nameof(tags));

            if (!targets.IsSet)
                throw new ArgumentException("Property is required for class DtoTrigger.", nameof(targets));

            if (!throttling.IsSet)
                throw new ArgumentException("Property is required for class DtoTrigger.", nameof(throttling));

            if (!triggerSource.IsSet)
                throw new ArgumentException("Property is required for class DtoTrigger.", nameof(triggerSource));

            if (!triggerType.IsSet)
                throw new ArgumentException("Property is required for class DtoTrigger.", nameof(triggerType));

            if (!updatedBy.IsSet)
                throw new ArgumentException("Property is required for class DtoTrigger.", nameof(updatedBy));

            if (!createdAt.IsSet)
                throw new ArgumentException("Property is required for class DtoTrigger.", nameof(createdAt));

            if (!errorValue.IsSet)
                throw new ArgumentException("Property is required for class DtoTrigger.", nameof(errorValue));

            if (!updatedAt.IsSet)
                throw new ArgumentException("Property is required for class DtoTrigger.", nameof(updatedAt));

            if (!warnValue.IsSet)
                throw new ArgumentException("Property is required for class DtoTrigger.", nameof(warnValue));

            if (aloneMetrics.IsSet && aloneMetrics.Value == null)
                throw new ArgumentNullException(nameof(aloneMetrics), "Property is not nullable for class DtoTrigger.");

            if (clusterId.IsSet && clusterId.Value == null)
                throw new ArgumentNullException(nameof(clusterId), "Property is not nullable for class DtoTrigger.");

            if (createdBy.IsSet && createdBy.Value == null)
                throw new ArgumentNullException(nameof(createdBy), "Property is not nullable for class DtoTrigger.");

            if (expression.IsSet && expression.Value == null)
                throw new ArgumentNullException(nameof(expression), "Property is not nullable for class DtoTrigger.");

            if (id.IsSet && id.Value == null)
                throw new ArgumentNullException(nameof(id), "Property is not nullable for class DtoTrigger.");

            if (isRemote.IsSet && isRemote.Value == null)
                throw new ArgumentNullException(nameof(isRemote), "Property is not nullable for class DtoTrigger.");

            if (muteNewMetrics.IsSet && muteNewMetrics.Value == null)
                throw new ArgumentNullException(nameof(muteNewMetrics), "Property is not nullable for class DtoTrigger.");

            if (name.IsSet && name.Value == null)
                throw new ArgumentNullException(nameof(name), "Property is not nullable for class DtoTrigger.");

            if (patterns.IsSet && patterns.Value == null)
                throw new ArgumentNullException(nameof(patterns), "Property is not nullable for class DtoTrigger.");

            if (tags.IsSet && tags.Value == null)
                throw new ArgumentNullException(nameof(tags), "Property is not nullable for class DtoTrigger.");

            if (targets.IsSet && targets.Value == null)
                throw new ArgumentNullException(nameof(targets), "Property is not nullable for class DtoTrigger.");

            if (throttling.IsSet && throttling.Value == null)
                throw new ArgumentNullException(nameof(throttling), "Property is not nullable for class DtoTrigger.");

            if (triggerSource.IsSet && triggerSource.Value == null)
                throw new ArgumentNullException(nameof(triggerSource), "Property is not nullable for class DtoTrigger.");

            if (triggerType.IsSet && triggerType.Value == null)
                throw new ArgumentNullException(nameof(triggerType), "Property is not nullable for class DtoTrigger.");

            if (updatedBy.IsSet && updatedBy.Value == null)
                throw new ArgumentNullException(nameof(updatedBy), "Property is not nullable for class DtoTrigger.");

            if (ttl.IsSet && ttl.Value == null)
                throw new ArgumentNullException(nameof(ttl), "Property is not nullable for class DtoTrigger.");

            return new DtoTrigger(aloneMetrics.Value, clusterId.Value, createdBy.Value, expression.Value, id.Value, isRemote.Value.Value, muteNewMetrics.Value.Value, name.Value, patterns.Value, tags.Value, targets.Value, throttling.Value.Value, triggerSource.Value, triggerType.Value, updatedBy.Value, createdAt.Value, desc, errorValue.Value, sched, ttl, ttlState, updatedAt.Value, warnValue.Value);
        }

        /// <summary>
        /// Serializes a <see cref="DtoTrigger" />
        /// </summary>
        /// <param name="writer"></param>
        /// <param name="dtoTrigger"></param>
        /// <param name="jsonSerializerOptions"></param>
        /// <exception cref="NotImplementedException"></exception>
        public override void Write(Utf8JsonWriter writer, DtoTrigger dtoTrigger, JsonSerializerOptions jsonSerializerOptions)
        {
            writer.WriteStartObject();

            WriteProperties(writer, dtoTrigger, jsonSerializerOptions);
            writer.WriteEndObject();
        }

        /// <summary>
        /// Serializes the properties of <see cref="DtoTrigger" />
        /// </summary>
        /// <param name="writer"></param>
        /// <param name="dtoTrigger"></param>
        /// <param name="jsonSerializerOptions"></param>
        /// <exception cref="NotImplementedException"></exception>
        public void WriteProperties(Utf8JsonWriter writer, DtoTrigger dtoTrigger, JsonSerializerOptions jsonSerializerOptions)
        {
            if (dtoTrigger.AloneMetrics == null)
                throw new ArgumentNullException(nameof(dtoTrigger.AloneMetrics), "Property is required for class DtoTrigger.");

            if (dtoTrigger.ClusterId == null)
                throw new ArgumentNullException(nameof(dtoTrigger.ClusterId), "Property is required for class DtoTrigger.");

            if (dtoTrigger.CreatedBy == null)
                throw new ArgumentNullException(nameof(dtoTrigger.CreatedBy), "Property is required for class DtoTrigger.");

            if (dtoTrigger.Expression == null)
                throw new ArgumentNullException(nameof(dtoTrigger.Expression), "Property is required for class DtoTrigger.");

            if (dtoTrigger.Id == null)
                throw new ArgumentNullException(nameof(dtoTrigger.Id), "Property is required for class DtoTrigger.");

            if (dtoTrigger.Name == null)
                throw new ArgumentNullException(nameof(dtoTrigger.Name), "Property is required for class DtoTrigger.");

            if (dtoTrigger.Patterns == null)
                throw new ArgumentNullException(nameof(dtoTrigger.Patterns), "Property is required for class DtoTrigger.");

            if (dtoTrigger.Tags == null)
                throw new ArgumentNullException(nameof(dtoTrigger.Tags), "Property is required for class DtoTrigger.");

            if (dtoTrigger.Targets == null)
                throw new ArgumentNullException(nameof(dtoTrigger.Targets), "Property is required for class DtoTrigger.");

            if (dtoTrigger.TriggerSource == null)
                throw new ArgumentNullException(nameof(dtoTrigger.TriggerSource), "Property is required for class DtoTrigger.");

            if (dtoTrigger.TriggerType == null)
                throw new ArgumentNullException(nameof(dtoTrigger.TriggerType), "Property is required for class DtoTrigger.");

            if (dtoTrigger.UpdatedBy == null)
                throw new ArgumentNullException(nameof(dtoTrigger.UpdatedBy), "Property is required for class DtoTrigger.");

            writer.WritePropertyName("alone_metrics");
            JsonSerializer.Serialize(writer, dtoTrigger.AloneMetrics, jsonSerializerOptions);
            writer.WriteString("cluster_id", dtoTrigger.ClusterId);

            writer.WriteString("created_by", dtoTrigger.CreatedBy);

            writer.WriteString("expression", dtoTrigger.Expression);

            writer.WriteString("id", dtoTrigger.Id);

            writer.WriteBoolean("is_remote", dtoTrigger.IsRemote);

            writer.WriteBoolean("mute_new_metrics", dtoTrigger.MuteNewMetrics);

            writer.WriteString("name", dtoTrigger.Name);

            writer.WritePropertyName("patterns");
            JsonSerializer.Serialize(writer, dtoTrigger.Patterns, jsonSerializerOptions);
            writer.WritePropertyName("tags");
            JsonSerializer.Serialize(writer, dtoTrigger.Tags, jsonSerializerOptions);
            writer.WritePropertyName("targets");
            JsonSerializer.Serialize(writer, dtoTrigger.Targets, jsonSerializerOptions);
            writer.WriteNumber("throttling", dtoTrigger.Throttling);

            writer.WriteString("trigger_source", dtoTrigger.TriggerSource);

            writer.WriteString("trigger_type", dtoTrigger.TriggerType);

            writer.WriteString("updated_by", dtoTrigger.UpdatedBy);

            if (dtoTrigger.CreatedAt != null)
                writer.WriteString("created_at", dtoTrigger.CreatedAt);
            else
                writer.WriteNull("created_at");

            if (dtoTrigger.DescOption.IsSet)
                if (dtoTrigger.DescOption.Value != null)
                    writer.WriteString("desc", dtoTrigger.Desc);
                else
                    writer.WriteNull("desc");

            if (dtoTrigger.ErrorValue != null)
                writer.WriteNumber("error_value", dtoTrigger.ErrorValue.Value);
            else
                writer.WriteNull("error_value");

            if (dtoTrigger.SchedOption.IsSet)
                if (dtoTrigger.SchedOption.Value != null)
                {
                    writer.WritePropertyName("sched");
                    JsonSerializer.Serialize(writer, dtoTrigger.Sched, jsonSerializerOptions);
                }
                else
                    writer.WriteNull("sched");
            if (dtoTrigger.TtlOption.IsSet)
                writer.WriteNumber("ttl", dtoTrigger.TtlOption.Value.Value);

            if (dtoTrigger.TtlStateOption.IsSet)
                if (dtoTrigger.TtlStateOption.Value != null)
                    writer.WriteString("ttl_state", dtoTrigger.TtlState);
                else
                    writer.WriteNull("ttl_state");

            if (dtoTrigger.UpdatedAt != null)
                writer.WriteString("updated_at", dtoTrigger.UpdatedAt);
            else
                writer.WriteNull("updated_at");

            if (dtoTrigger.WarnValue != null)
                writer.WriteNumber("warn_value", dtoTrigger.WarnValue.Value);
            else
                writer.WriteNull("warn_value");
        }
    }
}
